<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, viewport-fit=cover"
    />
    <title>Ruleta</title>
    <style>
      /* Fondo b√°sico */
      html,
      body {
        height: 100%;
        margin: 0;
      }
      body {
        background: #000 url("images/fondoruleta.png") center/cover no-repeat
          fixed;
        color: #fff;
        font-family: system-ui, Arial, sans-serif;
      }

      /* Layout sencillo */
      #app {
        position: fixed;
        inset: 0;
        display: grid;
        grid-template-rows: auto 1fr auto;
        align-items: center;
        justify-items: center;
      }

      .top,
      .bottom {
        text-align: center;
        padding: 8px;
      }
      .badge {
        display: inline-block;
        padding: 6px 12px;
        background: #d60000;
        color: #fff;
        font-weight: 700;
      }
      .title {
        margin: 8px 0 0;
        font-size: 24px;
      }

      .stage {
        top: 100px;
        width: min(92vmin, 850px);
        aspect-ratio: 1;
        display: grid;
        place-items: center;
        position: relative;
      }
      .wheel {
        width: 100%;
        aspect-ratio: 1;
        border-radius: 50%;
        transition: transform 5s cubic-bezier(0.12, 0.62, 0.02, 1);
        transform: rotate(var(--deg, 0deg));
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      /* Confeti y capa de tap */
      #confetti {
        position: fixed;
        inset: 0;
        pointer-events: none;
      }
      #tap-layer {
        position: fixed;
        inset: 0;
        background: transparent;
        border: 0;
      }
      /* PUNTERO ARRIBA ‚Äî APUNTANDO HACIA ABAJO */
      .pointer {
        /* ‚úÖ Ajusta aqu√≠ el tama√±o del puntero */
        --ptr-width: 40px; /* ancho de cada lado del tri√°ngulo ‚Äî cambia esto */
        --ptr-height: 120px; /* alto del tri√°ngulo ‚Äî cambia esto */
        --ptr-enter: 0; /* cu√°nto ‚Äúentra‚Äù sobre la ruleta ‚Äî negativo = m√°s adentro */

        position: absolute;
        top: var(--ptr-enter);
        left: 50%;
        transform: translateX(-50%);
        z-index: 5;

        width: 0;
        height: 0;
        border-left: var(--ptr-width) solid transparent;
        border-right: var(--ptr-width) solid transparent;
        border-top: var(--ptr-height) solid #000; /* ‚á© apunta hacia abajo */
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
      }

      /* Layout sencillo (mantenemos tu grid pero con gaps) */
      #app {
        position: fixed;
        inset: 0;
        display: grid;
        grid-template-rows: auto 1fr auto;
        align-items: center;
        justify-items: center;
        /* gap vertical controlado por perillas */
        row-gap: var(--space-mid);
        padding-top: calc(env(safe-area-inset-top, 0px) + var(--space-top));
        padding-bottom: calc(
          env(safe-area-inset-bottom, 0px) + var(--space-bot)
        );
      }

      /* Bloque superior (badge + title) */
      .top {
        text-align: center;
        padding: 0; /* limpiamos padding fijo */
        display: grid;
        gap: 8px; /* espacio peque√±o entre badge y title */
      }

      /* ===== Perillas independientes (NO comparten variables) ===== */
      :root {
        /* Badge */
        --badge-left-vp: 60%; /* 0‚Äì100% del ancho de la ventana */
        --badge-top-vp: 260px; /* px desde la parte superior */
        --badge-scale: 1;
        --badge-rotate: -8deg;
        --badge-size: clamp(24px, 2.6vmin, 26px);
        --badge-pad-y: 0.6em;
        --badge-pad-x: 0.9em;
        --badge-radius: 10px;
        --badge-z: 60;

        /* Title (totalmente independiente del badge) */
        --title-left-vp: 50%;
        --title-top-vp: 150px; /* mueve el t√≠tulo sin afectar el badge */
        --title-scale: 1;
        --title-size: clamp(130px, 3.4vmin + 4px, 48px);
        --title-weight: 800;
        --title-track: 0.4px;

        --title-z: 50;
      }

      /* Badge fijo: no afecta el flujo ni a otros elementos */
      .badge {
        position: fixed;
        left: var(--badge-left-vp);
        top: var(--badge-top-vp);
        transform: translateX(-50%) rotate(var(--badge-rotate))
          scale(var(--badge-scale));
        transform-origin: center;
        z-index: var(--badge-z);
        pointer-events: none; /* no bloquea taps en la ruleta */
        font-family: "Munito", system-ui, Arial, sans-serif;

        display: inline-block;
        background: #d60000;
        color: #fff;
        font-weight: 900;
        font-size: var(--badge-size);
        padding: var(--badge-pad-y) var(--badge-pad-x);
        letter-spacing: 10px;
        line-height: 1;
        text-transform: uppercase;
        box-shadow: 0 1px 0 rgba(0, 0, 0, 0.25);
      }

      @font-face {
        font-family: "Anton";
        src: url("../public/fonts/Anton-Regular.ttf") format("truetype");
        font-weight: 600;
        font-style: normal;
      }

      @font-face {
        font-family: "Munito";
        src: url("../public/fonts/Nunito.ttf") format("truetype");
        font-style: normal;
      }

      body h1 {
        font-family: "Anton", system-ui, Arial, sans-serif;
      }

      /* T√≠tulo fijo: independiente del badge */
      .title {
        position: fixed;
        left: var(--title-left-vp);
        top: var(--title-top-vp);
        transform: translateX(-50%) scale(var(--title-scale));
        z-index: var(--title-z);
        pointer-events: none;

        margin: 0;
        font-size: var(--title-size);
        font-weight: var(--title-weight);
        letter-spacing: 5px;
        line-height: 1.1;
        max-width: min(90vw, 900px);
        text-align: center;
        white-space: nowrap; /* 1 l√≠nea; qu√≠talo para multilinea */
        overflow: hidden;
        text-overflow: ellipsis;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.35);
      }
      /* Texto inferior */
      .bottom {
        text-align: center;
        padding: 0; /* limpiamos padding fijo */
      }

      #bottom-text {
        position: fixed;
        left: 50%;
        bottom: clamp(200px, 4vmin, 40px);
        transform: translateX(-50%);
        z-index: 10;
        pointer-events: none;

        max-width: min(92vw, 900px);
        text-align: center;

        /* üîí una sola l√≠nea */
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;

        /* tipograf√≠a */
        font-style: italic;
        font-size: clamp(56px, 2.5vmin + 6px, 28px);
        font-weight: 700;
        line-height: 1.2;
        letter-spacing: 0.2px;
        opacity: 0.95;

        /* aseg√∫rate de NO tener esto en otra regla:
     text-wrap: balance;  (qu√≠talo si aparece) */
        hyphens: none;
        -webkit-hyphens: none;
      }

      #bottom-text {
        text-shadow: 0 0 6px rgba(255, 255, 255, 0.35);
        animation: glowPulse 1.2s ease-in-out infinite;
      }

      @keyframes glowPulse {
        0%,
        100% {
          transform: translateX(-50%) scale(1.2);
          text-shadow: 0 0 6px rgba(255, 255, 255, 0.35),
            0 0 18px rgba(255, 255, 255, 0.15);
        }
        50% {
          transform: translateX(-50%) scale(1.04);
          text-shadow: 0 0 10px rgba(255, 255, 255, 0.55),
            0 0 26px rgba(255, 255, 255, 0.25);
        }
      }
      #tap-layer {
        position: fixed;
        inset: 0;
        background: transparent;
        border: 0;
        z-index: 20000; /* üëà por encima de badge/title/ruleta */
        pointer-events: auto; /* üëà recibe clic antes del giro */
      }

      /* Overlay del premio */
      #prize-overlay {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 90000;
        background: rgba(255, 255, 255, 0.6);
        backdrop-filter: blur(6px);
        pointer-events: none;
      }

      /* Confeti POR ENCIMA DEL overlay */
      #confetti {
        position: fixed;
        inset: 0;
        z-index: 999999; /* ‚úÖ arriba del overlay */
        pointer-events: none;
      }

      /* Imagen del premio M√ÅS ARRIBA QUE EL CONFETI */
      #prize-img {
        position: relative;
        z-index: 10000; /* ‚úÖ para que no quede cubierto por confeti */
        max-width: 70vw;
        max-height: 70vh;
        object-fit: contain;
      }

      #prize-label {
        font-family: "AntonLocal", system-ui, Arial, sans-serif; /* o la tuya */
        font-size: clamp(22px, 4.2vmin, 36px);
        font-weight: 800;
        letter-spacing: 0.4px;
      }

      .btn_back {
        position: absolute;
        width: 100px;
        top: 170px;
        right: 90px;
        cursor: pointer;
        z-index: 1000;
      }

      /* Cursor durante el tipeo */
      .typing::after {
        content: "‚ñå";
        margin-left: 2px;
        animation: blink 0.9s steps(1) infinite;
      }
      @keyframes blink {
        50% {
          opacity: 0;
        }
      }

      /* Zoom inverso para el badge */
      .badge--zoom-inverse {
        /* empieza grande y transparente; termina en su escala normal */
        animation: badgeZoomIn 0.55s cubic-bezier(0.2, 0.9, 0.2, 1) forwards;
      }
      @keyframes badgeZoomIn {
        0% {
          opacity: 0;
          transform: translateX(-50%) rotate(var(--badge-rotate)) scale(2.4);
          filter: blur(2px);
        }
        100% {
          opacity: 1;
          transform: translateX(-50%) rotate(var(--badge-rotate))
            scale(var(--badge-scale));
          filter: blur(0);
        }
      }

      /* Oculta el texto del premio */
      #prize-label {
        display: none;
      }

      /* Overlay suave */
      #prize-overlay {
        opacity: 0;
        transition: opacity 0.25s ease;
      }

      /* Imagen del premio: solo zoom limpio */
      #prize-img {
        opacity: 0;
        transform: scale(0.7);
        will-change: transform, opacity;
      }
      #prize-img.zoom-in {
        animation: prizeZoom 0.5s cubic-bezier(0.2, 0.9, 0.2, 1) forwards;
      }
      @keyframes prizeZoom {
        0% {
          opacity: 0;
          transform: scale(0.7);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <!-- Textos superiores -->
      <div class="top">
        <div class="badge" id="badge-text" style="opacity: 0"></div>
        <h1 class="title" id="title-text" style="opacity: 0"></h1>
      </div>

      <!-- Ruleta -->
      <div class="stage">
        <div class="pointer"></div>
        <div class="wheel" id="wheel">
          <canvas id="wheel-canvas" width="1000" height="1000"></canvas>
        </div>
      </div>

      <!-- Texto inferior -->
      <div class="bottom">
        <div id="bottom-text" style="opacity: 0"></div>
      </div>

      <div class="bottom">
        <div id="bottom-text">¬°GIRA LA RULETA Y GANA!</div>
      </div>

      <!-- Efectos/interacci√≥n -->
      <canvas id="confetti"></canvas>
      <button id="tap-layer" aria-label="Tocar para girar"></button>
      <!-- Overlay de premio -->
      <div id="prize-overlay" aria-live="polite" style="display: none">
        <div class="prize-card">
          <img id="prize-img" alt="Premio" />
          <div id="prize-label" style="opacity: 0">¬°Ganaste!</div>
        </div>
      </div>
    </div>

    <audio id="spin-sound" preload="auto">
      <source src="sounds/spin.mp3" type="audio/mpeg" />
      <source src="sounds/spin.ogg" type="audio/ogg" />
    </audio>

    <div class="btnback" onclick="window.location.href='index.html'">
      <img class="btn_back" src="./images/homeblanck.png" />
    </div>
    <script>
      (function () {
        // ===== Configuraci√≥n =====
        // 9 im√°genes (una por partici√≥n, en orden horario empezando arriba)
        const SLOTS = [
          "images/slot01.png",
          "images/slot02.png",
          "images/slot03.png",
          "images/slot04.png",
          "images/slot06.png",
          // "images/slot06.png",  // eliminado
          "images/slot07.png",
          "images/slot08.png",
          "images/slot09.png",
        ];

        // Texto del overlay por cada slot (exactamente 9)
        const PRIZE_LABELS = [
          "Sigue Intentando",
          "Hola",
          "Hola",
          "Hola",
          "Hola",
          "Hola",
          "Hola",
          "Hola",
        ];

        const spinSnd = document.getElementById("spin-sound");

        const REDIRECT_URL = "ruleta.html";

        const TOP_TEXT = "¬°Gira la ruleta y gana!";
        const BADGE_TEXT = "¬°SUERTE";
        const BOTTOM_TEXT = "Toca en cualquier parte para comenzar a girar";

        // === T√≠tulo que se escribe solo, luego badge con zoom inverso ===
        const titleEl = document.getElementById("title-text");
        const badgeEl = document.getElementById("badge-text");

        // Define aqu√≠ qu√© quieres que se ‚Äútipee‚Äù arriba.
        // Si quieres dos l√≠neas, usa un salto de l√≠nea \n
        const TITLE_TO_TYPE = "RULETA DE\nREGALOS"; // c√°mbialo si prefieres tu TOP_TEXT
        const BADGE_TO_SHOW = BADGE_TEXT || "¬°SUERTE!";

        function typeWrite(el, fullText, speed = 45, done) {
          el.style.opacity = "1";
          el.classList.add("typing");
          // Soporte de salto de l√≠nea con \n
          const chars = fullText.split("");
          el.textContent = "";

          let i = 0;
          function step() {
            // manejar \n a <br>
            if (chars[i] === "\n") {
              el.innerHTML += "<br/>";
            } else {
              el.innerHTML += chars[i];
            }
            i++;
            if (i < chars.length) {
              setTimeout(step, speed);
            } else {
              el.classList.remove("typing"); // quita cursor
              if (typeof done === "function") done();
            }
          }
          step();
        }

        // Orquesta: primero escribe el t√≠tulo, luego muestra el badge con zoom inverso
        function runTitleThenBadge() {
          // fuerza contenido y estado inicial
          titleEl.innerHTML = "";
          titleEl.style.opacity = "0";
          badgeEl.textContent = BADGE_TO_SHOW;
          badgeEl.style.opacity = "0";
          badgeEl.classList.remove("badge--zoom-inverse");

          // Arranca el tipeo
          setTimeout(() => {
            typeWrite(titleEl, TITLE_TO_TYPE, 45, () => {
              // cuando termina el tipeo, aparece el badge
              requestAnimationFrame(() => {
                // peque√±o delay para que se sienta ‚Äúdespu√©s‚Äù
                setTimeout(() => {
                  badgeEl.style.opacity = "1";
                  badgeEl.classList.add("badge--zoom-inverse");
                }, 160);
              });
            });
          }, 250);
        }

        // Lanza la secuencia al cargar
        window.addEventListener("load", () => {
          runTitleThenBadge();
        });

        // DOM
        const wheel = document.getElementById("wheel");
        const canvas = document.getElementById("wheel-canvas");
        const ctx = canvas.getContext("2d");

        const confettiCanvas = document.getElementById("confetti");
        const cctx = confettiCanvas.getContext("2d");

        // Ojo: tienes 2 elementos con id="bottom-text" en el HTML.
        // document.getElementById() devuelve el primero. Funciona, pero lo ideal es dejar solo uno.
        document.getElementById("title-text").textContent = TOP_TEXT;
        document.getElementById("badge-text").textContent = BADGE_TEXT;
        document.getElementById("bottom-text").textContent = BOTTOM_TEXT;

        const tapLayer = document.getElementById("tap-layer");
        const overlay = document.getElementById("prize-overlay");
        const prizeImg = document.getElementById("prize-img");
        const prizeText = document.getElementById("prize-label");

        function showPrizeOverlay(index) {
          prizeImg.src = SLOTS[index];

          // mostrar overlay
          overlay.style.display = "flex";
          // reset anim
          prizeImg.classList.remove("zoom-in");
          // forzar reflow para reiniciar la animaci√≥n
          void prizeImg.offsetWidth;

          // fade-in del overlay
          requestAnimationFrame(() => {
            overlay.style.opacity = "1";
            // dispara el zoom del premio
            prizeImg.classList.add("zoom-in");
          });
        }

        function hidePrizeOverlay() {
          overlay.style.opacity = "0";
          setTimeout(() => {
            overlay.style.display = "none";
          }, 250);
        }

        // DPR
        const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

        // Geometr√≠a ruleta
        const PARTS = SLOTS.length; // <<<<<< clave: ahora 9
        const TWO_PI = Math.PI * 2;
        const SLICE = TWO_PI / PARTS;

        // Colores alternos + aro exterior blanco
        const COLORS = ["#fefefe", "#a6a6a6", "#dcdcdc"];
        const WHITE_RING = 10;
        const GAP_RING = 22;

        // -------- Precarga de im√°genes --------
        let imgs = new Array(PARTS).fill(null);

        function loadImage(src, idx) {
          return new Promise((resolve) => {
            const im = new Image();
            im.onload = async () => {
              if (im.decode) {
                try {
                  await im.decode();
                } catch (e) {}
              }
              imgs[idx] = im;
              resolve(true);
            };
            im.onerror = () => {
              imgs[idx] = null;
              resolve(false);
            };
            im.src = src;
          });
        }

        async function preloadAll() {
          await Promise.all(SLOTS.map((src, i) => loadImage(src, i)));
          drawWheel();
        }

        // -------- Canvas size & draw --------
        function resizeWheelCanvas() {
          const box = canvas.parentElement.getBoundingClientRect();
          const width = Math.max(1, Math.floor(box.width));
          const height = Math.max(1, Math.floor(box.height));
          canvas.width = Math.round(width * DPR);
          canvas.height = Math.round(height * DPR);
          canvas.style.width = width + "px";
          canvas.style.height = height + "px";
          ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
          drawWheel();
        }

        function drawWheel() {
          const w = canvas.width / DPR;
          const h = canvas.height / DPR;
          if (w <= 0 || h <= 0) return;

          const cx = w / 2,
            cy = h / 2;
          ctx.clearRect(0, 0, w, h);

          const R_max = Math.min(w, h) / 2;
          const R_sectors = R_max - WHITE_RING - GAP_RING - 1;
          const R_ringMid = R_sectors + GAP_RING + WHITE_RING / 2;
          const innerR = R_sectors * 0.1;

          for (let i = 0; i < PARTS; i++) {
            const start = i * SLICE - Math.PI / 2;
            const end = start + SLICE;

            // sector
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.arc(cx, cy, R_sectors, start, end);
            ctx.closePath();
            ctx.fillStyle = COLORS[i % 3];
            ctx.fill();

            // imagen
            const mid = (start + end) / 2;
            const img = imgs[i];
            const IMG_SCALE = 0.35;
            const RADIAL = 0.62;
            const IMG_MAX = 700;

            const imgSize = Math.min(R_sectors * IMG_SCALE, IMG_MAX);
            const px = cx + Math.cos(mid) * (R_sectors * RADIAL);
            const py = cy + Math.sin(mid) * (R_sectors * RADIAL);

            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(mid + Math.PI / 2);
            if (img && img.naturalWidth > 0) {
              ctx.drawImage(img, -imgSize / 2, -imgSize / 2, imgSize, imgSize);
            } else {
              // placeholder
              ctx.fillStyle = "#000";
              ctx.fillRect(-18, -12, 36, 24);
              ctx.fillStyle = "#fff";
              ctx.font = "bold 16px system-ui";
              ctx.textAlign = "center";
              ctx.textBaseline = "middle";
              ctx.fillText(String(i + 1), 0, 0);
            }
            ctx.restore();
          }

          // centro
          ctx.beginPath();
          ctx.arc(cx, cy, innerR, 0, TWO_PI);
          ctx.fillStyle = "black";
          ctx.fill();

          ctx.beginPath();
          ctx.arc(cx, cy, innerR * 0.82, 0, TWO_PI);
          ctx.fillStyle = "#328290";
          ctx.fill();

          // anillo blanco exterior
          ctx.save();
          ctx.lineWidth = WHITE_RING;
          ctx.strokeStyle = "#ffffff";
          ctx.beginPath();
          ctx.arc(cx, cy, R_ringMid, 0, TWO_PI);
          ctx.stroke();
          ctx.restore();
        }

        // Redibujar progresivo al cargar im√°genes
        SLOTS.forEach((src, i) => {
          const im = new Image();
          im.onload = async () => {
            if (im.decode) {
              try {
                await im.decode();
              } catch (e) {}
            }
            imgs[i] = im;
            drawWheel();
          };
          im.onerror = () => {
            imgs[i] = null;
            drawWheel();
          };
          im.src = src;
        });

        // Resize + preload
        if (window.ResizeObserver)
          new ResizeObserver(resizeWheelCanvas).observe(canvas);
        else window.addEventListener("resize", resizeWheelCanvas);
        window.addEventListener("orientationchange", () =>
          setTimeout(resizeWheelCanvas, 150)
        );

        window.addEventListener("load", () => {
          requestAnimationFrame(resizeWheelCanvas);
          preloadAll();
        });

        // ---- Giro con tap ----
        let spinning = false;
        let hasSpun = false;
        let currentDeg = 0;

        const sliceDeg = 360 / PARTS;

        // pesos ajustados a PARTS
        const WEIGHTS = Array(PARTS).fill(1);

        function pickWeighted(weights) {
          const total = weights.reduce((a, b) => a + Math.max(0, b), 0) || 1;
          let r = Math.random() * total,
            acc = 0;
          for (let i = 0; i < weights.length; i++) {
            acc += Math.max(0, weights[i]);
            if (r <= acc) return i;
          }
          return weights.length - 1;
        }

        function fadeOut(audio, ms = 200) {
          return new Promise((resolve) => {
            if (!audio) return resolve();
            const startVol = audio.volume ?? 1;
            const steps = 10;
            const stepTime = ms / steps;
            let i = 0;
            const iv = setInterval(() => {
              i++;
              audio.volume = Math.max(0, startVol * (1 - i / steps));
              if (i >= steps) {
                clearInterval(iv);
                try {
                  audio.pause();
                  audio.currentTime = 0;
                } catch (e) {}
                audio.volume = startVol; // deja el volumen listo para la pr√≥xima
                resolve();
              }
            }, stepTime);
          });
        }

        async function stopSpinSound(immediate = false) {
          if (!spinSnd) return;
          if (immediate) {
            try {
              spinSnd.pause();
              spinSnd.currentTime = 0;
            } catch (e) {}
            return;
          }
          await fadeOut(spinSnd, 200); // 200ms de desvanecido
        }

        function spin() {
          if (spinning || hasSpun) return;

          const tap = document.getElementById("tap-layer");
          if (tap) tap.style.pointerEvents = "none";

          // üîä sonido de inicio (en el mismo gesto del usuario, permitido por m√≥viles)
          if (spinSnd) {
            try {
              spinSnd.currentTime = 0;
              spinSnd.volume = 1; // ajusta si quieres
              spinSnd.play().catch(() => {});
            } catch (e) {}
          }

          spinning = true;
          hasSpun = true;
          document.getElementById("bottom-text").textContent = "Girando‚Ä¶";

          const winner = pickWeighted(WEIGHTS);
          window.__lastWinner = winner;

          const targetAbs = -(winner + 0.5) * sliceDeg;
          const extraTurns = 5 + Math.floor(Math.random() * 4);
          const targetAbsNorm = ((targetAbs % 360) + 360) % 360;

          let d = (targetAbsNorm - currentDeg) % 360;
          if (d < 0) d += 360;

          const target = currentDeg + extraTurns * 360 + d;

          wheel.style.setProperty("--deg", target + "deg");
          currentDeg = targetAbsNorm;
        }

        wheel.addEventListener("transitionend", async () => {
          spinning = false;
          const winner = window.__lastWinner ?? 0;

          // 1) Det√©n el sonido del giro (fade-out)
          await stopSpinSound(false); // o stopSpinSound(true) si quieres corte inmediato

          // 2) Lanza el confeti otra vez üéâ
          releaseConfetti();

          // 3) Muestra el premio con zoom
          showPrizeOverlay(winner);

          // 4) Oculta y redirige
          setTimeout(() => {
            hidePrizeOverlay();
            window.location.href = REDIRECT_URL; // ruleta.html
          }, 4000);
        });

        tapLayer.addEventListener("click", spin, { passive: true });
        tapLayer.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault();
            spin();
          },
          { passive: false }
        );

        // ---- Confeti ----
        function resizeConfetti() {
          confettiCanvas.width = window.innerWidth * DPR;
          confettiCanvas.height = window.innerHeight * DPR;
          cctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        }
        window.addEventListener("resize", resizeConfetti);
        resizeConfetti();

        let confettiParticles = [];
        let animating = false;
        let redirectPending = false;

        function releaseConfetti() {
          const count = 120;
          const stage = document
            .querySelector(".stage")
            .getBoundingClientRect();
          const fromX = stage.left + stage.width / 2;
          const fromY = stage.top + stage.height * 0.2;

          for (let i = 0; i < count; i++) {
            confettiParticles.push({
              x: fromX + (Math.random() * 140 - 70),
              y: fromY,
              vx: Math.random() * 6 - 3,
              vy: -Math.random() * 10 - 6,
              g: 0.32 + Math.random() * 0.2,
              size: 6 + Math.random() * 6,
              rot: Math.random() * Math.PI * 2,
              vr: (Math.random() - 0.5) * 0.2,
              alpha: 1,
              shape: Math.random() < 0.5 ? "rect" : "circle",
              color: `hsl(${Math.floor(Math.random() * 360)},85%,60%)`,
            });
          }
          if (!animating) animateConfetti();
        }

        function animateConfetti() {
          animating = true;
          const w = confettiCanvas.width / DPR;
          const h = confettiCanvas.height / DPR;
          cctx.clearRect(0, 0, w, h);

          confettiParticles.forEach((p) => {
            p.vy += p.g;
            p.x += p.vx;
            p.y += p.vy;
            p.rot += p.vr;
            p.alpha -= 0.006;
            cctx.globalAlpha = Math.max(0, p.alpha);
            cctx.save();
            cctx.translate(p.x, p.y);
            cctx.rotate(p.rot);
            cctx.fillStyle = p.color;
            if (p.shape === "rect")
              cctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.6);
            else {
              cctx.beginPath();
              cctx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
              cctx.fill();
            }
            cctx.restore();
          });
          cctx.globalAlpha = 1;

          confettiParticles = confettiParticles.filter(
            (p) => p.alpha > 0 && p.y < h + 40
          );

          if (confettiParticles.length > 0) {
            requestAnimationFrame(animateConfetti);
          } else {
            animating = false;
            if (redirectPending) {
              redirectPending = false;
              setTimeout(() => {
                window.location.href = REDIRECT_URL;
              }, 250);
            }
          }
        }
      })();
    </script>
  </body>
</html>
